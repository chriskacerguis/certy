
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>certy: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/chriskacerguis/certy/ca.go (69.0%)</option>
				
				<option value="file1">github.com/chriskacerguis/certy/cert.go (82.1%)</option>
				
				<option value="file2">github.com/chriskacerguis/certy/config.go (78.8%)</option>
				
				<option value="file3">github.com/chriskacerguis/certy/main.go (6.3%)</option>
				
				<option value="file4">github.com/chriskacerguis/certy/pkcs12.go (66.7%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "crypto/rand"
        "crypto/rsa"
        "crypto/x509"
        "crypto/x509/pkix"
        "encoding/pem"
        "fmt"
        "math/big"
        "os"
        "time"
)

// installCA creates the root CA and intermediate CA infrastructure
func installCA() error <span class="cov8" title="21">{
        // Ensure certy directory exists
        dir, err := getCertyDir()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="21">if err := os.MkdirAll(dir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create certy directory: %w", err)
        }</span>

        // Load or create config
        <span class="cov8" title="21">cfg := DefaultConfig()
        if err := saveConfig(cfg); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to save config: %w", err)
        }</span>

        // Generate root CA
        <span class="cov8" title="21">fmt.Println("Generating root CA...")
        rootKey, rootCert, err := generateRootCA(cfg)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to generate root CA: %w", err)
        }</span>

        // Save root CA
        <span class="cov8" title="21">if err := saveKeyAndCert(rootKey, rootCert, "rootCA"); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to save root CA: %w", err)
        }</span>

        // Generate intermediate CA
        <span class="cov8" title="21">fmt.Println("Generating intermediate CA...")
        intKey, intCert, err := generateIntermediateCA(rootKey, rootCert, cfg)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to generate intermediate CA: %w", err)
        }</span>

        // Save intermediate CA
        <span class="cov8" title="21">if err := saveKeyAndCert(intKey, intCert, "intermediateCA"); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to save intermediate CA: %w", err)
        }</span>

        // Initialize serial number file
        <span class="cov8" title="21">serialPath, err := getCAFilePath("serial.txt")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="21">if err := os.WriteFile(serialPath, []byte("1"), 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to initialize serial file: %w", err)
        }</span>

        <span class="cov8" title="21">return nil</span>
}

// generateRootCA generates a self-signed root CA certificate
func generateRootCA(cfg *Config) (*rsa.PrivateKey, *x509.Certificate, error) <span class="cov8" title="25">{
        // Generate private key
        privateKey, err := rsa.GenerateKey(rand.Reader, cfg.DefaultKeySize)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to generate private key: %w", err)
        }</span>

        // Create certificate template
        <span class="cov8" title="25">serialNumber, err := rand.Int(rand.Reader, new(big.Int).Lsh(big.NewInt(1), 128))
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to generate serial number: %w", err)
        }</span>

        <span class="cov8" title="25">template := &amp;x509.Certificate{
                SerialNumber: serialNumber,
                Subject: pkix.Name{
                        CommonName:   "Certy Root CA",
                        Organization: []string{"Certy"},
                },
                NotBefore:             time.Now(),
                NotAfter:              time.Now().AddDate(0, 0, cfg.RootCAValidityDays),
                KeyUsage:              x509.KeyUsageCertSign | x509.KeyUsageCRLSign,
                BasicConstraintsValid: true,
                IsCA:                  true,
                MaxPathLen:            1,
                MaxPathLenZero:        false,
        }

        // Create self-signed certificate
        certDER, err := x509.CreateCertificate(rand.Reader, template, template, &amp;privateKey.PublicKey, privateKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to create certificate: %w", err)
        }</span>

        // Parse certificate
        <span class="cov8" title="25">cert, err := x509.ParseCertificate(certDER)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to parse certificate: %w", err)
        }</span>

        <span class="cov8" title="25">return privateKey, cert, nil</span>
}

// generateIntermediateCA generates an intermediate CA certificate signed by the root CA
func generateIntermediateCA(rootKey *rsa.PrivateKey, rootCert *x509.Certificate, cfg *Config) (*rsa.PrivateKey, *x509.Certificate, error) <span class="cov8" title="22">{
        // Generate private key
        privateKey, err := rsa.GenerateKey(rand.Reader, cfg.DefaultKeySize)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to generate private key: %w", err)
        }</span>

        // Create certificate template
        <span class="cov8" title="22">serialNumber, err := rand.Int(rand.Reader, new(big.Int).Lsh(big.NewInt(1), 128))
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to generate serial number: %w", err)
        }</span>

        <span class="cov8" title="22">template := &amp;x509.Certificate{
                SerialNumber: serialNumber,
                Subject: pkix.Name{
                        CommonName:   "Certy Intermediate CA",
                        Organization: []string{"Certy"},
                },
                NotBefore:             time.Now(),
                NotAfter:              time.Now().AddDate(0, 0, cfg.IntCAValidityDays),
                KeyUsage:              x509.KeyUsageCertSign | x509.KeyUsageCRLSign,
                BasicConstraintsValid: true,
                IsCA:                  true,
                MaxPathLen:            0,
                MaxPathLenZero:        true,
        }

        // Create certificate signed by root CA
        certDER, err := x509.CreateCertificate(rand.Reader, template, rootCert, &amp;privateKey.PublicKey, rootKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to create certificate: %w", err)
        }</span>

        // Parse certificate
        <span class="cov8" title="22">cert, err := x509.ParseCertificate(certDER)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to parse certificate: %w", err)
        }</span>

        <span class="cov8" title="22">return privateKey, cert, nil</span>
}

// saveKeyAndCert saves a private key and certificate to PEM files
func saveKeyAndCert(key *rsa.PrivateKey, cert *x509.Certificate, baseName string) error <span class="cov10" title="44">{
        // Save private key
        keyPath, err := getCAFilePath(baseName + "-key.pem")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov10" title="44">keyFile, err := os.OpenFile(keyPath, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0600)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create key file: %w", err)
        }</span>
        <span class="cov10" title="44">defer keyFile.Close()

        keyPEM := &amp;pem.Block{
                Type:  "RSA PRIVATE KEY",
                Bytes: x509.MarshalPKCS1PrivateKey(key),
        }
        if err := pem.Encode(keyFile, keyPEM); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write key file: %w", err)
        }</span>

        // Save certificate
        <span class="cov10" title="44">certPath, err := getCAFilePath(baseName + ".pem")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov10" title="44">certFile, err := os.Create(certPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create certificate file: %w", err)
        }</span>
        <span class="cov10" title="44">defer certFile.Close()

        certPEM := &amp;pem.Block{
                Type:  "CERTIFICATE",
                Bytes: cert.Raw,
        }
        if err := pem.Encode(certFile, certPEM); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write certificate file: %w", err)
        }</span>

        <span class="cov10" title="44">return nil</span>
}

// loadIntermediateCA loads the intermediate CA key and certificate
func loadIntermediateCA() (*rsa.PrivateKey, *x509.Certificate, error) <span class="cov9" title="29">{
        // Load private key
        keyPath, err := getCAFilePath("intermediateCA-key.pem")
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov9" title="29">keyData, err := os.ReadFile(keyPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to read intermediate CA key: %w", err)
        }</span>

        <span class="cov9" title="29">keyBlock, _ := pem.Decode(keyData)
        if keyBlock == nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to decode intermediate CA key PEM")
        }</span>

        <span class="cov9" title="29">privateKey, err := x509.ParsePKCS1PrivateKey(keyBlock.Bytes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to parse intermediate CA key: %w", err)
        }</span>

        // Load certificate
        <span class="cov9" title="29">certPath, err := getCAFilePath("intermediateCA.pem")
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov9" title="29">certData, err := os.ReadFile(certPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to read intermediate CA certificate: %w", err)
        }</span>

        <span class="cov9" title="29">certBlock, _ := pem.Decode(certData)
        if certBlock == nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to decode intermediate CA certificate PEM")
        }</span>

        <span class="cov9" title="29">cert, err := x509.ParseCertificate(certBlock.Bytes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to parse intermediate CA certificate: %w", err)
        }</span>

        <span class="cov9" title="29">return privateKey, cert, nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "crypto/ecdsa"
        "crypto/elliptic"
        "crypto/rand"
        "crypto/rsa"
        "crypto/x509"
        "crypto/x509/pkix"
        "encoding/pem"
        "fmt"
        "math/big"
        "net"
        "os"
        "path/filepath"
        "strings"
        "time"
)

// CertificateType represents the type of certificate to generate
type CertificateType int

const (
        CertTypeTLS CertificateType = iota
        CertTypeClient
        CertTypeSMIME
)

// generateCertificate generates a certificate based on the inputs
func generateCertificate(inputs []string, certType CertificateType, useECDSA bool, certFile, keyFile string, cfg *Config) (string, string, error) <span class="cov8" title="23">{
        // Load intermediate CA
        caKey, caCert, err := loadIntermediateCA()
        if err != nil </span><span class="cov0" title="0">{
                return "", "", err
        }</span>

        // Generate key pair
        <span class="cov8" title="23">var privateKey interface{}
        var publicKey interface{}

        if useECDSA </span><span class="cov3" title="3">{
                ecdsaKey, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)
                if err != nil </span><span class="cov0" title="0">{
                        return "", "", fmt.Errorf("failed to generate ECDSA key: %w", err)
                }</span>
                <span class="cov3" title="3">privateKey = ecdsaKey
                publicKey = &amp;ecdsaKey.PublicKey</span>
        } else<span class="cov8" title="20"> {
                rsaKey, err := rsa.GenerateKey(rand.Reader, cfg.DefaultKeySize)
                if err != nil </span><span class="cov0" title="0">{
                        return "", "", fmt.Errorf("failed to generate RSA key: %w", err)
                }</span>
                <span class="cov8" title="20">privateKey = rsaKey
                publicKey = &amp;rsaKey.PublicKey</span>
        }

        // Get serial number
        <span class="cov8" title="23">serial, err := getSerialNumber()
        if err != nil </span><span class="cov0" title="0">{
                return "", "", err
        }</span>

        // Parse inputs into SANs
        <span class="cov8" title="23">dnsNames, ipAddresses, emailAddresses := parseInputs(inputs)

        // Determine common name
        commonName := determineCommonName(inputs, certType)

        // Create certificate template
        template := &amp;x509.Certificate{
                SerialNumber: big.NewInt(serial),
                Subject: pkix.Name{
                        CommonName: commonName,
                },
                NotBefore:             time.Now(),
                NotAfter:              time.Now().AddDate(0, 0, cfg.DefaultValidityDays),
                DNSNames:              dnsNames,
                IPAddresses:           ipAddresses,
                EmailAddresses:        emailAddresses,
                BasicConstraintsValid: true,
                IsCA:                  false,
        }

        // Set key usage based on certificate type
        switch certType </span>{
        case CertTypeTLS:<span class="cov8" title="19">
                template.KeyUsage = x509.KeyUsageDigitalSignature | x509.KeyUsageKeyEncipherment
                template.ExtKeyUsage = []x509.ExtKeyUsage{x509.ExtKeyUsageServerAuth}</span>
        case CertTypeClient:<span class="cov2" title="2">
                template.KeyUsage = x509.KeyUsageDigitalSignature
                template.ExtKeyUsage = []x509.ExtKeyUsage{x509.ExtKeyUsageClientAuth}</span>
        case CertTypeSMIME:<span class="cov2" title="2">
                template.KeyUsage = x509.KeyUsageDigitalSignature | x509.KeyUsageKeyEncipherment
                template.ExtKeyUsage = []x509.ExtKeyUsage{x509.ExtKeyUsageEmailProtection}</span>
        }

        // Create certificate
        <span class="cov8" title="23">certDER, err := x509.CreateCertificate(rand.Reader, template, caCert, publicKey, caKey)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", fmt.Errorf("failed to create certificate: %w", err)
        }</span>

        // Parse certificate
        <span class="cov8" title="23">cert, err := x509.ParseCertificate(certDER)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", fmt.Errorf("failed to parse certificate: %w", err)
        }</span>

        // Determine output file paths
        <span class="cov8" title="23">certPath, keyPath := determineOutputPaths(inputs, certFile, keyFile)

        // Save certificate
        if err := saveCertificate(cert, certPath); err != nil </span><span class="cov0" title="0">{
                return "", "", err
        }</span>

        // Save private key
        <span class="cov8" title="23">if err := savePrivateKey(privateKey, keyPath); err != nil </span><span class="cov0" title="0">{
                return "", "", err
        }</span>

        <span class="cov8" title="23">return certPath, keyPath, nil</span>
}

// parseInputs parses the inputs into DNS names, IP addresses, and email addresses
func parseInputs(inputs []string) ([]string, []net.IP, []string) <span class="cov9" title="29">{
        var dnsNames []string
        var ipAddresses []net.IP
        var emailAddresses []string

        for _, input := range inputs </span><span class="cov10" title="38">{
                // Check if it's an IP address
                if ip := net.ParseIP(input); ip != nil </span><span class="cov6" title="8">{
                        ipAddresses = append(ipAddresses, ip)
                        continue</span>
                }

                // Check if it's an email address
                <span class="cov9" title="30">if strings.Contains(input, "@") </span><span class="cov4" title="4">{
                        emailAddresses = append(emailAddresses, input)
                        continue</span>
                }

                // Otherwise, it's a DNS name
                <span class="cov9" title="26">dnsNames = append(dnsNames, input)</span>
        }

        <span class="cov9" title="29">return dnsNames, ipAddresses, emailAddresses</span>
}

// determineCommonName determines the common name for the certificate
func determineCommonName(inputs []string, certType CertificateType) string <span class="cov9" title="27">{
        if len(inputs) == 0 </span><span class="cov0" title="0">{
                return "Unknown"
        }</span>

        // For S/MIME, use the email address
        <span class="cov9" title="27">if certType == CertTypeSMIME </span><span class="cov3" title="3">{
                for _, input := range inputs </span><span class="cov3" title="3">{
                        if strings.Contains(input, "@") </span><span class="cov3" title="3">{
                                return input
                        }</span>
                }
        }

        // Use the first input as the common name
        <span class="cov8" title="24">return inputs[0]</span>
}

// determineOutputPaths determines the output file paths for the certificate and key
func determineOutputPaths(inputs []string, certFile, keyFile string) (string, string) <span class="cov9" title="28">{
        // If custom paths are provided, use them
        if certFile != "" &amp;&amp; keyFile != "" </span><span class="cov2" title="2">{
                return certFile, keyFile
        }</span>

        // Generate default paths based on first input
        <span class="cov9" title="26">baseName := sanitizeFilename(inputs[0])
        if len(inputs) &gt; 1 </span><span class="cov4" title="4">{
                baseName = fmt.Sprintf("%s+%d", baseName, len(inputs)-1)
        }</span>

        <span class="cov9" title="26">certPath := certFile
        if certPath == "" </span><span class="cov9" title="26">{
                certPath = fmt.Sprintf("./%s.pem", baseName)
        }</span>

        <span class="cov9" title="26">keyPath := keyFile
        if keyPath == "" </span><span class="cov9" title="26">{
                keyPath = fmt.Sprintf("./%s-key.pem", baseName)
        }</span>

        <span class="cov9" title="26">return certPath, keyPath</span>
}

// sanitizeFilename sanitizes a string to be used as a filename
func sanitizeFilename(s string) string <span class="cov9" title="33">{
        // Remove invalid characters
        s = strings.ReplaceAll(s, "*", "wildcard")
        s = strings.ReplaceAll(s, ":", "-")
        s = strings.ReplaceAll(s, "/", "-")
        s = strings.ReplaceAll(s, "\\", "-")
        s = strings.ReplaceAll(s, "@", "-at-")
        return s
}</span>

// saveCertificate saves a certificate to a PEM file
func saveCertificate(cert *x509.Certificate, path string) error <span class="cov9" title="27">{
        // Ensure directory exists
        dir := filepath.Dir(path)
        if dir != "." &amp;&amp; dir != "" </span><span class="cov3" title="3">{
                if err := os.MkdirAll(dir, 0755); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create directory: %w", err)
                }</span>
        }

        <span class="cov9" title="27">certFile, err := os.Create(path)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create certificate file: %w", err)
        }</span>
        <span class="cov9" title="27">defer certFile.Close()

        certPEM := &amp;pem.Block{
                Type:  "CERTIFICATE",
                Bytes: cert.Raw,
        }
        if err := pem.Encode(certFile, certPEM); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write certificate file: %w", err)
        }</span>

        <span class="cov9" title="27">return nil</span>
}

// savePrivateKey saves a private key to a PEM file
func savePrivateKey(key interface{}, path string) error <span class="cov8" title="23">{
        // Ensure directory exists
        dir := filepath.Dir(path)
        if dir != "." &amp;&amp; dir != "" </span><span class="cov1" title="1">{
                if err := os.MkdirAll(dir, 0755); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create directory: %w", err)
                }</span>
        }

        <span class="cov8" title="23">keyFile, err := os.OpenFile(path, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0600)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create key file: %w", err)
        }</span>
        <span class="cov8" title="23">defer keyFile.Close()

        var keyPEM *pem.Block

        switch k := key.(type) </span>{
        case *rsa.PrivateKey:<span class="cov8" title="20">
                keyPEM = &amp;pem.Block{
                        Type:  "RSA PRIVATE KEY",
                        Bytes: x509.MarshalPKCS1PrivateKey(k),
                }</span>
        case *ecdsa.PrivateKey:<span class="cov3" title="3">
                keyBytes, err := x509.MarshalECPrivateKey(k)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to marshal ECDSA key: %w", err)
                }</span>
                <span class="cov3" title="3">keyPEM = &amp;pem.Block{
                        Type:  "EC PRIVATE KEY",
                        Bytes: keyBytes,
                }</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported key type")</span>
        }

        <span class="cov8" title="23">if err := pem.Encode(keyFile, keyPEM); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write key file: %w", err)
        }</span>

        <span class="cov8" title="23">return nil</span>
}

// generateFromCSR generates a certificate from a CSR file
func generateFromCSR(csrPath, certFile string, cfg *Config) (string, error) <span class="cov4" title="4">{
        // Load CSR
        csrData, err := os.ReadFile(csrPath)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to read CSR file: %w", err)
        }</span>

        <span class="cov4" title="4">csrBlock, _ := pem.Decode(csrData)
        if csrBlock == nil </span><span class="cov1" title="1">{
                return "", fmt.Errorf("failed to decode CSR PEM")
        }</span>

        <span class="cov3" title="3">csr, err := x509.ParseCertificateRequest(csrBlock.Bytes)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to parse CSR: %w", err)
        }</span>

        // Verify CSR signature
        <span class="cov3" title="3">if err := csr.CheckSignature(); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("invalid CSR signature: %w", err)
        }</span>

        // Load intermediate CA
        <span class="cov3" title="3">caKey, caCert, err := loadIntermediateCA()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Get serial number
        <span class="cov3" title="3">serial, err := getSerialNumber()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Create certificate template from CSR
        <span class="cov3" title="3">template := &amp;x509.Certificate{
                SerialNumber:          big.NewInt(serial),
                Subject:               csr.Subject,
                NotBefore:             time.Now(),
                NotAfter:              time.Now().AddDate(0, 0, cfg.DefaultValidityDays),
                DNSNames:              csr.DNSNames,
                IPAddresses:           csr.IPAddresses,
                EmailAddresses:        csr.EmailAddresses,
                KeyUsage:              x509.KeyUsageDigitalSignature | x509.KeyUsageKeyEncipherment,
                ExtKeyUsage:           []x509.ExtKeyUsage{x509.ExtKeyUsageServerAuth, x509.ExtKeyUsageClientAuth},
                BasicConstraintsValid: true,
                IsCA:                  false,
        }

        // Create certificate
        certDER, err := x509.CreateCertificate(rand.Reader, template, caCert, csr.PublicKey, caKey)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create certificate: %w", err)
        }</span>

        // Parse certificate
        <span class="cov3" title="3">cert, err := x509.ParseCertificate(certDER)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to parse certificate: %w", err)
        }</span>

        // Determine output path
        <span class="cov3" title="3">certPath := certFile
        if certPath == "" </span><span class="cov2" title="2">{
                // Use CSR filename with .pem extension
                base := strings.TrimSuffix(filepath.Base(csrPath), filepath.Ext(csrPath))
                certPath = fmt.Sprintf("./%s.pem", base)
        }</span>

        // Save certificate
        <span class="cov3" title="3">if err := saveCertificate(cert, certPath); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov3" title="3">return certPath, nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import (
        "fmt"
        "os"
        "path/filepath"

        "gopkg.in/yaml.v3"
)

// Config represents the certy configuration
type Config struct {
        DefaultValidityDays int    `yaml:"default_validity_days"`
        RootCAValidityDays  int    `yaml:"root_ca_validity_days"`
        IntCAValidityDays   int    `yaml:"intermediate_ca_validity_days"`
        DefaultKeyType      string `yaml:"default_key_type"`
        DefaultKeySize      int    `yaml:"default_key_size"`
}

// DefaultConfig returns the default configuration
func DefaultConfig() *Config <span class="cov7" title="53">{
        return &amp;Config{
                DefaultValidityDays: 365,
                RootCAValidityDays:  3650,
                IntCAValidityDays:   1825,
                DefaultKeyType:      "rsa",
                DefaultKeySize:      2048,
        }
}</span>

// getCertyDir returns the directory where certy stores its files
func getCertyDir() (string, error) <span class="cov10" title="282">{
        // Priority 1: Use custom directory if specified via -ca-dir flag
        if customCADir != "" </span><span class="cov9" title="280">{
                absPath, err := filepath.Abs(customCADir)
                if err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("failed to resolve CA directory path: %w", err)
                }</span>
                <span class="cov9" title="280">return absPath, nil</span>
        }

        // Priority 2: Use CAROOT environment variable if set
        <span class="cov2" title="2">if caroot := os.Getenv("CAROOT"); caroot != "" </span><span class="cov1" title="1">{
                absPath, err := filepath.Abs(caroot)
                if err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("failed to resolve CAROOT path: %w", err)
                }</span>
                <span class="cov1" title="1">return absPath, nil</span>
        }

        // Priority 3: Default to ~/.certy
        <span class="cov1" title="1">home, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get home directory: %w", err)
        }</span>
        <span class="cov1" title="1">return filepath.Join(home, ".certy"), nil</span>
}

// getConfigPath returns the path to the config file
func getConfigPath() (string, error) <span class="cov7" title="45">{
        dir, err := getCertyDir()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov7" title="45">return filepath.Join(dir, "config.yml"), nil</span>
}

// loadConfig loads the configuration from file or returns defaults
func loadConfig() (*Config, error) <span class="cov5" title="22">{
        configPath, err := getConfigPath()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // If config file doesn't exist, return defaults
        <span class="cov5" title="22">if _, err := os.Stat(configPath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return DefaultConfig(), nil
        }</span>

        // Read config file
        <span class="cov5" title="22">data, err := os.ReadFile(configPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read config file: %w", err)
        }</span>

        // Parse YAML
        <span class="cov5" title="22">cfg := DefaultConfig()
        if err := yaml.Unmarshal(data, cfg); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse config file: %w", err)
        }</span>

        // Validate configuration
        <span class="cov5" title="22">if err := validateConfig(cfg); err != nil </span><span class="cov2" title="2">{
                return nil, fmt.Errorf("invalid configuration: %w", err)
        }</span>

        <span class="cov5" title="20">return cfg, nil</span>
}

// validateConfig validates the configuration values
func validateConfig(cfg *Config) error <span class="cov7" title="64">{
        // Validate validity periods
        if cfg.DefaultValidityDays &lt; 1 </span><span class="cov3" title="4">{
                return fmt.Errorf("default_validity_days must be at least 1, got %d", cfg.DefaultValidityDays)
        }</span>
        <span class="cov7" title="60">if cfg.DefaultValidityDays &gt; 825 </span><span class="cov1" title="1">{
                return fmt.Errorf("default_validity_days cannot exceed 825 (27 months), got %d", cfg.DefaultValidityDays)
        }</span>

        <span class="cov7" title="59">if cfg.RootCAValidityDays &lt; 365 </span><span class="cov1" title="1">{
                return fmt.Errorf("root_ca_validity_days must be at least 365, got %d", cfg.RootCAValidityDays)
        }</span>
        <span class="cov7" title="58">if cfg.RootCAValidityDays &gt; 7300 </span><span class="cov1" title="1">{
                return fmt.Errorf("root_ca_validity_days cannot exceed 7300 (20 years), got %d", cfg.RootCAValidityDays)
        }</span>

        <span class="cov7" title="57">if cfg.IntCAValidityDays &lt; 365 </span><span class="cov1" title="1">{
                return fmt.Errorf("intermediate_ca_validity_days must be at least 365, got %d", cfg.IntCAValidityDays)
        }</span>
        <span class="cov7" title="56">if cfg.IntCAValidityDays &gt; 3650 </span><span class="cov1" title="1">{
                return fmt.Errorf("intermediate_ca_validity_days cannot exceed 3650 (10 years), got %d", cfg.IntCAValidityDays)
        }</span>

        // Validate key type
        <span class="cov7" title="55">if cfg.DefaultKeyType != "rsa" &amp;&amp; cfg.DefaultKeyType != "ecdsa" </span><span class="cov2" title="2">{
                return fmt.Errorf("default_key_type must be 'rsa' or 'ecdsa', got '%s'", cfg.DefaultKeyType)
        }</span>

        // Validate key size
        <span class="cov7" title="53">if cfg.DefaultKeyType == "rsa" </span><span class="cov7" title="49">{
                // RSA key sizes must be 2048, 3072, or 4096
                if cfg.DefaultKeySize != 2048 &amp;&amp; cfg.DefaultKeySize != 3072 &amp;&amp; cfg.DefaultKeySize != 4096 </span><span class="cov1" title="1">{
                        return fmt.Errorf("default_key_size for RSA must be 2048, 3072, or 4096, got %d", cfg.DefaultKeySize)
                }</span>
        } else<span class="cov3" title="4"> if cfg.DefaultKeyType == "ecdsa" </span><span class="cov3" title="4">{
                // ECDSA key sizes must be 256, 384, or 521 (P-256, P-384, P-521)
                if cfg.DefaultKeySize != 256 &amp;&amp; cfg.DefaultKeySize != 384 &amp;&amp; cfg.DefaultKeySize != 521 </span><span class="cov1" title="1">{
                        return fmt.Errorf("default_key_size for ECDSA must be 256, 384, or 521, got %d", cfg.DefaultKeySize)
                }</span>
        }

        // Validate intermediate CA validity is less than root CA
        <span class="cov7" title="51">if cfg.IntCAValidityDays &gt;= cfg.RootCAValidityDays </span><span class="cov1" title="1">{
                return fmt.Errorf("intermediate_ca_validity_days (%d) must be less than root_ca_validity_days (%d)",
                        cfg.IntCAValidityDays, cfg.RootCAValidityDays)
        }</span>

        <span class="cov7" title="50">return nil</span>
}

// saveConfig saves the configuration to file
func saveConfig(cfg *Config) error <span class="cov6" title="24">{
        // Validate before saving
        if err := validateConfig(cfg); err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("invalid configuration: %w", err)
        }</span>

        <span class="cov6" title="23">configPath, err := getConfigPath()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Ensure directory exists
        <span class="cov6" title="23">dir := filepath.Dir(configPath)
        if err := os.MkdirAll(dir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create config directory: %w", err)
        }</span>

        // Marshal to YAML
        <span class="cov6" title="23">data, err := yaml.Marshal(cfg)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal config: %w", err)
        }</span>

        // Write to file
        <span class="cov6" title="23">if err := os.WriteFile(configPath, data, 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write config file: %w", err)
        }</span>

        <span class="cov6" title="23">return nil</span>
}

// getCAFilePath returns the path to a CA file
func getCAFilePath(filename string) (string, error) <span class="cov9" title="213">{
        dir, err := getCertyDir()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov9" title="213">return filepath.Join(dir, filename), nil</span>
}

// caExists checks if the CA infrastructure is installed
func caExists() bool <span class="cov3" title="4">{
        files := []string{"rootCA.pem", "rootCA-key.pem", "intermediateCA.pem", "intermediateCA-key.pem"}
        for _, file := range files </span><span class="cov4" title="10">{
                path, err := getCAFilePath(file)
                if err != nil </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov4" title="10">if _, err := os.Stat(path); os.IsNotExist(err) </span><span class="cov2" title="2">{
                        return false
                }</span>
        }
        <span class="cov2" title="2">return true</span>
}

// getSerialNumber reads and increments the serial number
func getSerialNumber() (int64, error) <span class="cov6" title="29">{
        serialPath, err := getCAFilePath("serial.txt")
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        // Initialize serial file if it doesn't exist
        <span class="cov6" title="29">if _, err := os.Stat(serialPath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                if err := os.WriteFile(serialPath, []byte("1"), 0644); err != nil </span><span class="cov0" title="0">{
                        return 0, fmt.Errorf("failed to initialize serial file: %w", err)
                }</span>
                <span class="cov0" title="0">return 1, nil</span>
        }

        // Read current serial
        <span class="cov6" title="29">data, err := os.ReadFile(serialPath)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to read serial file: %w", err)
        }</span>

        <span class="cov6" title="29">var serial int64
        if _, err := fmt.Sscanf(string(data), "%d", &amp;serial); err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to parse serial number: %w", err)
        }</span>

        // Increment and save
        <span class="cov6" title="29">nextSerial := serial + 1
        if err := os.WriteFile(serialPath, []byte(fmt.Sprintf("%d", nextSerial)), 0644); err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to update serial file: %w", err)
        }</span>

        <span class="cov6" title="29">return serial, nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package main

import (
        "flag"
        "fmt"
        "os"
        "path/filepath"
        "strings"
)

var version = "dev"
var customCADir string // Global variable for custom CA directory

func main() <span class="cov0" title="0">{
        // Define flags
        installFlag := flag.Bool("install", false, "Create a rootCA with an intermediateCA")
        caDirFlag := flag.String("ca-dir", "", "Custom directory for CA files (default: ~/.certy or $CAROOT)")
        carootFlag := flag.Bool("CAROOT", false, "Print the CA root directory path and exit")
        certFileFlag := flag.String("cert-file", "", "Customize the certificate output path")
        keyFileFlag := flag.String("key-file", "", "Customize the key output path")
        p12FileFlag := flag.String("p12-file", "", "Customize the PKCS#12 output path")
        p12PasswordFlag := flag.String("p12-password", "", "Password for PKCS#12 file (empty for no password)")
        clientFlag := flag.Bool("client", false, "Generate a certificate for client authentication")
        ecdsaFlag := flag.Bool("ecdsa", false, "Generate a certificate with an ECDSA key")
        pkcs12Flag := flag.Bool("pkcs12", false, "Generate a PKCS#12 file")
        csrFlag := flag.String("csr", "", "Generate a certificate based on the supplied CSR")

        flag.Usage = func() </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "certy %s - Simple Certificate Authority CLI\n\n", version)
                fmt.Fprintf(os.Stderr, "Usage:\n")
                fmt.Fprintf(os.Stderr, "  certy [options] [domains/IPs/email...]\n\n")
                fmt.Fprintf(os.Stderr, "Examples:\n")
                fmt.Fprintf(os.Stderr, "  certy -install                                    # Initialize CA infrastructure\n")
                fmt.Fprintf(os.Stderr, "  certy example.com \"*.example.com\" 127.0.0.1      # Generate TLS certificate\n")
                fmt.Fprintf(os.Stderr, "  certy user@domain.com                             # Generate S/MIME certificate\n")
                fmt.Fprintf(os.Stderr, "  certy -client user@domain.com                     # Generate client auth certificate\n\n")
                fmt.Fprintf(os.Stderr, "Options:\n")
                flag.PrintDefaults()
        }</span>

        <span class="cov0" title="0">flag.Parse()

        // Set custom CA directory if provided via -ca-dir flag
        if *caDirFlag != "" </span><span class="cov0" title="0">{
                customCADir = *caDirFlag
        }</span>

        // Handle -CAROOT flag (print CA directory and exit)
        <span class="cov0" title="0">if *carootFlag </span><span class="cov0" title="0">{
                dir, err := getCertyDir()
                if err != nil </span><span class="cov0" title="0">{
                        fatal("Failed to get CA directory: %v", err)
                }</span>
                <span class="cov0" title="0">fmt.Println(dir)
                return</span>
        }

        // Validate flag conflicts
        <span class="cov0" title="0">if *csrFlag != "" </span><span class="cov0" title="0">{
                if *clientFlag || *ecdsaFlag || *pkcs12Flag || flag.NArg() &gt; 0 </span><span class="cov0" title="0">{
                        fatal("The -csr flag conflicts with all other flags except -install, -cert-file, -key-file, and -p12-file")
                }</span>
        }

        // Handle -install flag
        <span class="cov0" title="0">if *installFlag </span><span class="cov0" title="0">{
                if err := installCA(); err != nil </span><span class="cov0" title="0">{
                        fatal("Failed to install CA: %v", err)
                }</span>
                <span class="cov0" title="0">fmt.Println("✓ CA infrastructure installed successfully")
                if !*installFlag &amp;&amp; flag.NArg() == 0 &amp;&amp; *csrFlag == "" </span><span class="cov0" title="0">{
                        return
                }</span>
        }

        // Check if we have work to do
        <span class="cov0" title="0">if flag.NArg() == 0 &amp;&amp; *csrFlag == "" </span><span class="cov0" title="0">{
                if !*installFlag </span><span class="cov0" title="0">{
                        flag.Usage()
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">return</span>
        }

        // Ensure CA is installed before generating certificates
        <span class="cov0" title="0">if !caExists() </span><span class="cov0" title="0">{
                fatal("CA not found. Please run 'certy -install' first to initialize the CA infrastructure.")
        }</span>

        // Load configuration
        <span class="cov0" title="0">cfg, err := loadConfig()
        if err != nil </span><span class="cov0" title="0">{
                fatal("Failed to load configuration: %v", err)
        }</span>

        // Generate certificate
        <span class="cov0" title="0">var certPath, keyPath, p12Path string

        if *csrFlag != "" </span><span class="cov0" title="0">{
                // Generate from CSR
                certPath, err = generateFromCSR(*csrFlag, *certFileFlag, cfg)
                if err != nil </span><span class="cov0" title="0">{
                        fatal("Failed to generate certificate from CSR: %v", err)
                }</span>
                <span class="cov0" title="0">fmt.Printf("✓ Certificate generated: %s\n", certPath)</span>
        } else<span class="cov0" title="0"> {
                // Parse inputs
                inputs := flag.Args()
                if len(inputs) == 0 </span><span class="cov0" title="0">{
                        fatal("No domains, IPs, or email addresses provided")
                }</span>

                // Determine certificate type and generate
                <span class="cov0" title="0">certType := detectCertificateType(inputs, *clientFlag)

                certPath, keyPath, err = generateCertificate(inputs, certType, *ecdsaFlag, *certFileFlag, *keyFileFlag, cfg)
                if err != nil </span><span class="cov0" title="0">{
                        fatal("Failed to generate certificate: %v", err)
                }</span>

                <span class="cov0" title="0">fmt.Printf("✓ Certificate generated: %s\n", certPath)
                fmt.Printf("✓ Private key generated: %s\n", keyPath)

                // Generate PKCS#12 if requested
                if *pkcs12Flag </span><span class="cov0" title="0">{
                        if *p12FileFlag != "" </span><span class="cov0" title="0">{
                                p12Path = *p12FileFlag
                        }</span> else<span class="cov0" title="0"> {
                                p12Path = strings.TrimSuffix(certPath, filepath.Ext(certPath)) + ".p12"
                        }</span>

                        <span class="cov0" title="0">if err := generatePKCS12(certPath, keyPath, p12Path, *p12PasswordFlag); err != nil </span><span class="cov0" title="0">{
                                fatal("Failed to generate PKCS#12 file: %v", err)
                        }</span>
                        <span class="cov0" title="0">fmt.Printf("✓ PKCS#12 file generated: %s\n", p12Path)</span>
                }
        }
}

func fatal(format string, args ...interface{}) <span class="cov0" title="0">{
        fmt.Fprintf(os.Stderr, "Error: "+format+"\n", args...)
        os.Exit(1)
}</span>

func detectCertificateType(inputs []string, clientAuth bool) CertificateType <span class="cov10" title="4">{
        // Check if first input is an email (S/MIME)
        if len(inputs) &gt; 0 &amp;&amp; strings.Contains(inputs[0], "@") </span><span class="cov1" title="1">{
                return CertTypeSMIME
        }</span>

        // Client authentication
        <span class="cov8" title="3">if clientAuth </span><span class="cov1" title="1">{
                return CertTypeClient
        }</span>

        // Default to TLS server certificate
        <span class="cov5" title="2">return CertTypeTLS</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package main

import (
        "crypto/x509"
        "encoding/pem"
        "fmt"
        "os"

        "software.sslmate.com/src/go-pkcs12"
)

// generatePKCS12 generates a PKCS#12 file from a certificate and private key
// password parameter is optional - pass empty string for no password protection
func generatePKCS12(certPath, keyPath, p12Path, password string) error <span class="cov10" title="6">{
        // Read certificate
        certData, err := os.ReadFile(certPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read certificate: %w", err)
        }</span>

        <span class="cov10" title="6">certBlock, _ := pem.Decode(certData)
        if certBlock == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to decode certificate PEM")
        }</span>

        <span class="cov10" title="6">cert, err := x509.ParseCertificate(certBlock.Bytes)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse certificate: %w", err)
        }</span>

        // Read private key
        <span class="cov10" title="6">keyData, err := os.ReadFile(keyPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read private key: %w", err)
        }</span>

        <span class="cov10" title="6">keyBlock, _ := pem.Decode(keyData)
        if keyBlock == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to decode private key PEM")
        }</span>

        <span class="cov10" title="6">var privateKey interface{}
        switch keyBlock.Type </span>{
        case "RSA PRIVATE KEY":<span class="cov9" title="5">
                privateKey, err = x509.ParsePKCS1PrivateKey(keyBlock.Bytes)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to parse RSA private key: %w", err)
                }</span>
        case "EC PRIVATE KEY":<span class="cov1" title="1">
                privateKey, err = x509.ParseECPrivateKey(keyBlock.Bytes)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to parse EC private key: %w", err)
                }</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported private key type: %s", keyBlock.Type)</span>
        }

        // Load intermediate CA certificate for the chain
        <span class="cov10" title="6">intCACertPath, err := getCAFilePath("intermediateCA.pem")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov10" title="6">intCACertData, err := os.ReadFile(intCACertPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read intermediate CA certificate: %w", err)
        }</span>

        <span class="cov10" title="6">intCABlock, _ := pem.Decode(intCACertData)
        if intCABlock == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to decode intermediate CA certificate PEM")
        }</span>

        <span class="cov10" title="6">intCACert, err := x509.ParseCertificate(intCABlock.Bytes)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse intermediate CA certificate: %w", err)
        }</span>

        // Create PKCS#12 data with the certificate chain
        // If password is empty, no password protection is used
        <span class="cov10" title="6">pfxData, err := pkcs12.Modern.Encode(privateKey, cert, []*x509.Certificate{intCACert}, password)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to encode PKCS#12: %w", err)
        }</span>

        // Write PKCS#12 file
        <span class="cov10" title="6">if err := os.WriteFile(p12Path, pfxData, 0600); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write PKCS#12 file: %w", err)
        }</span>

        <span class="cov10" title="6">return nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
